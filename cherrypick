#!/bin/bash
# Cherrypick
# @author Matt Proctor
# Last update: 2022-01-13

########## VERSION 1.0
#
# Additions:
# Version 1.0 automates the creation of the cherry-picking commands by taking the git repo that it is called in
#       and collecting the branches. It then removes unwanted branches, adds in checkout commands and 
#       cherry-pick commands with the commit id and saves them all into pick.sh, which can be saved wherever 
#       the user prefers. User runs pick.sh, solves merge conflicts and manually removes previously cherry-picked
#       branches until everything is solved.
#
########## VERSION 2.0
#
# Additions:
# Version 2.0 automates the cherry-picking commands. No longer outputs to pick.sh, but holds them in an array.
#	Goes through all commands and executes them. If merge conflict occurs it automatically opens VS code
#	for the user to solve the merge conflict and then prompts the user for how they resolved it. Based off
#	of that, it automatically chooses to cherry-pick --abort or cherry-pick --continue and moves on to the
#	next branch until all branches are cherry-picked
#
# Version 2.1 removes the need to choose how you resolved the merge conflict. User now presses enter to confirm
#	that the conflict has been resolved and it will continue.

# Colors
BLACK='\033[0;30m'
RED='\033[0;31m'
ORANGE='\033[0;33m'
GREEN='\033[0;32m'
DGRAY='\033[1;30m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
PURPLE='\033[0;35m'
YELLOW='\033[1;33m'
LGREEN='\033[1;32m'
WHITE='\033[1;37m'

verbose=0

# Display help
Help() {
    echo "${NC}cherrypick automatically cherry-picks all of the branches in the git repo based off of the commit"
    echo
    echo "Must be called inside of a git repository"
    echo "Save this program in /usr/local/bin"
    echo "Usage: cherrypick"
    echo
    echo "When Merge conflict occurs: VS code will launch, solve the conflict and close the editor."
    echo "Return to the terminal and enter 'i' for the incoming change was accepted, or 'c' for the current change was accepted"
    echo
}

# Make sure command is ran inside of a git repo
if [ ! -d .git ]; then
	echo -e "${RED}Error: cherrypick must be called from inside of a git repository"
	exit 1
fi;

# Define arguments for script
while getopts :h: flag
do
    case "${flag}" in
	h) Help
	exit;;
    esac
done

if [[ $verbose -eq 1 ]]; then
    echo -e "${YELLOW}VERBOSE MODE ON"
fi

# Print current directory (aka repo)
# Get git commit id
id=$(git -C $PWD log | awk 'NR==1 {print $2}')

# Print commit id
echo -e "${DGRAY}Commit id: ${CYAN}${id}"

# Get initial branch to avoid cherry-picking
initial_branch=$(git rev-parse --abbrev-ref HEAD)

# Store branches in array
# 1. Gets all branches with 'git branch --all'
# 2. Removes unwanted branch names including HEAD, master, review, main, temp, and initial_branch
# 3. Removes ' remotes/origin/'
readarray -t branches < <(git -C $PWD branch -r | grep -v "$initial_branch" | grep -v "temp" | grep -v "HEAD" | grep -v "changes" | grep -v "review" | grep -v "main" | grep -v "master" | sed -e "s/  origin\///g" | sed -e "s/$//g")

# Get number of branches
num_branches=${#branches[@]}

# Start count for branches completed
count=0

# Print number of commands
echo -e "${DGRAY}Generated: ${LGREEN}($num_branches) ${CYAN}cherry-pick commands\n"

# Execute command in each branch
while [[ count -lt "${#branches[@]}" ]]; do

    # Get next branch
    branch=${branches[$count]}

    # Calculate percentage of branches cherry-picked
    percent_complete=$((($count+1)*100/$num_branches))

    # Checkout to branch
    checkout_result=$(git checkout $branch 2>&1)

    # Get current branch
    current_branch=$(git rev-parse --abbrev-ref HEAD)

    # Debug printing
    if [[ $verbose -eq 1 ]]; then
	echo -e "${YELLOW}Checkout to $branch, result:"
        echo -e "$checkout_result"
    fi

    # Detect Error: checkout to branch failed
    if echo $checkout_result | grep -q "error"; then

	# Detect Error: merge conflict
	if echo $checkout_result | grep -q "you need to resolve your current index first"; then

	    # This means you messed up real bad
	    echo -e "${RED}BAD: MERGE CONFLICT WAS NOT SOLVED"

	# Detect Error: repo has not committed before cherry-picking
	elif echo $checkout_result | grep -q "Your local changes to the following files would be overwritten by checkout"; then

	    echo -e "${RED}ERROR: unsaved changes in current branch ($current_branch) make sure to add changes and commit before cherry-picking"
	    exit 1

	# Detect Error: Unknown error occured
	else
	    # Alert user of unknown error, exit program
	    echo -e "${DGRAY}Checkout to $branch: ${RED}UNKNOWN ERROR - this error is not accounted for in the program"
	    echo -e "${RED}$checkout_result"
	    exit 1
	fi
    # Successful checkout to branch
    else
	# Cherry-pick branch
	cherrypick_result=$(git cherry-pick $id 2>&1)

	# Debug printing
	if [[ $verbose -eq 1 ]]; then
	    echo -e "${YELLOW}Cherry-pick result"
            echo -e "$cherrypick_result"
        fi

	# Detect Error: merge conflict
        if echo $cherrypick_result | grep -q "hint: after resolving the conflicts, mark the corrected paths"; then
	    # Alert user of merge conflict
            echo -e "${ORANGE}[!!]${DGRAY}Cherry-pick $current_branch: ${ORANGE}MERGE CONFLICT${GREEN}"

            # Open VS Code to solve merge conflict
            code .

	    echo -e "${DGRAY}Press ${LGREEN}[ENTER] ${DGRAY}when changes have been made${GREEN}"
	    read -s enter

	    git add . &>/dev/null
	    git cherry-pick --continue
	fi
    fi

    # Inform user of successful cherry-pick, branch complete
    echo -e "${LGREEN}[${percent_complete}%]${DGRAY}Cherry-pick $current_branch: ${LGREEN}COMPLETE"

    # Increment count (aka step to next branch)
    count=$((count+1))
done
